// apps/api/src/routes/predict.js
import "dotenv/config";
import express from "express";

const router = express.Router();

/**
 * Upstreams
 */
const NBA_API_BASE = "https://api.balldontlie.io/v1";
const NBA_API_KEY = process.env.NBA_API_KEY || "";

const NHL_API_BASE = "https://api-web.nhle.com/v1"; // kept for later, but NHL is paused right now

// ✅ ESPN
const ESPN_SITE_V2 = "https://site.api.espn.com/apis/site/v2/sports";
const ESPN_NCAAM_PATH = "basketball/mens-college-basketball";

// ✅ The Odds API (Vegas market lines) — optional but enables market anchoring for NBA
const ODDS_API_BASE = process.env.ODDS_API_BASE || "https://api.the-odds-api.com/v4";
const ODDS_API_KEY = process.env.ODDS_API_KEY || "";
const ODDS_BOOKMAKER = (process.env.ODDS_BOOKMAKER || "draftkings").toLowerCase();

/**
 * Cache (TTL + in-flight de-dupe + simple pruning)
 */
const CACHE_TTL_MS = 60_000;
const HEAVY_CACHE_TTL_MS = 20 * 60_000;
const MAX_CACHE_KEYS = 800;

const cache = new Map(); // key -> { time, ttl, value }
const inFlight = new Map(); // key -> Promise (upstream fetches)
const predInFlight = new Map(); // key -> Promise (computed predictions)

function pruneCacheIfNeeded() {
  if (cache.size <= MAX_CACHE_KEYS) return;
  const entries = [...cache.entries()].sort((a, b) => a[1].time - b[1].time);
  const removeN = Math.ceil(entries.length * 0.1);
  for (let i = 0; i < removeN; i++) cache.delete(entries[i][0]);
}

function getCache(key) {
  const hit = cache.get(key);
  if (!hit) return null;
  if (Date.now() - hit.time > hit.ttl) {
    cache.delete(key);
    return null;
  }
  return hit.value;
}

function setCache(key, value, ttl = CACHE_TTL_MS) {
  cache.set(key, { time: Date.now(), ttl, value });
  pruneCacheIfNeeded();
}

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function jitter(ms, pct = 0.2) {
  const j = ms * pct;
  return Math.max(0, Math.round(ms + (Math.random() * 2 - 1) * j));
}

function parseRetryAfterSeconds(res) {
  const ra = res?.headers?.get?.("retry-after");
  if (!ra) return null;
  const n = Number(ra);
  return Number.isFinite(n) ? n : null;
}

// Small per-host concurrency gate (prevents “imploding”)
const hostGates = new Map(); // host -> { active, queue: [] }

async function withHostGate(url, limit, fn) {
  const host = new URL(url).host;
  if (!hostGates.has(host)) hostGates.set(host, { active: 0, queue: [] });
  const gate = hostGates.get(host);

  if (gate.active >= limit) {
    await new Promise((resolve) => gate.queue.push(resolve));
  }
  gate.active += 1;
  try {
    return await fn();
  } finally {
    gate.active -= 1;
    const next = gate.queue.shift();
    if (next) next();
  }
}

async function fetchJson(url, opts = {}) {
  const {
    cacheKey = url,
    cacheTtlMs = CACHE_TTL_MS,
    retries = 5,
    retryBaseMs = 600,
    timeoutMs = 12_000,
    headers = {},
    hostConcurrency = 1, // ✅ reduce concurrency to avoid 429 spirals
  } = opts;

  // Cache hit
  const cached = getCache(cacheKey);
  if (cached) return cached;

  // In-flight de-dupe
  if (inFlight.has(cacheKey)) return inFlight.get(cacheKey);

  const promise = withHostGate(url, hostConcurrency, async () => {
    for (let attempt = 0; attempt <= retries; attempt++) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);

      try {
        const res = await fetch(url, {
          signal: ctrl.signal,
          headers: {
            "content-type": "application/json",
            ...headers,
          },
        });

        if (res.status === 429) {
          const ra = parseRetryAfterSeconds(res);
          const waitMs = ra != null ? ra * 1000 : jitter(retryBaseMs * Math.pow(2, attempt));
          if (attempt >= retries) {
            const body = await safeText(res);
            throw new Error(`Upstream 429 for ${url} — ${body || "Too many requests, please try again later."}`);
          }
          await sleep(waitMs);
          continue;
        }

        if (!res.ok) {
          const body = await safeText(res);
          throw new Error(`Upstream ${res.status} for ${url} — ${body || res.statusText}`);
        }

        const data = await res.json();
        setCache(cacheKey, data, cacheTtlMs);
        return data;
      } catch (e) {
        if (attempt >= retries) throw e;
        await sleep(jitter(retryBaseMs * Math.pow(2, attempt)));
      } finally {
        clearTimeout(t);
      }
    }
  });

  inFlight.set(cacheKey, promise);
  try {
    return await promise;
  } finally {
    inFlight.delete(cacheKey);
  }
}

async function safeText(res) {
  try {
    return await res.text();
  } catch {
    return "";
  }
}

function clamp(x, a, b) {
  return Math.max(a, Math.min(b, x));
}

function to2(x) {
  return Math.round(x * 100) / 100;
}

function to3(x) {
  return Math.round(x * 1000) / 1000;
}

function todayUTCYYYYMMDD() {
  const now = new Date();
  const utc = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
  return utc.toISOString().slice(0, 10);
}

function parseYmdOrDefault(s) {
  const v = String(s || "").slice(0, 10);
  if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return v;
  return todayUTCYYYYMMDD();
}

function ymdToUtcRange(ymd) {
  // The Odds API expects YYYY-MM-DDTHH:MM:SSZ (no milliseconds)
  const startIso = `${ymd}T00:00:00Z`;
  const endIso = `${ymd}T23:59:59Z`;
  return { startIso, endIso };
}

/**
 * Premium response contract helpers
 */
function toUnifiedTeam(league, raw) {
  if (!raw) return { id: null, name: null };
  if (league === "nba") {
    return {
      id: raw.id ? `nba-${raw.id}` : null,
      name: raw.abbreviation || raw.name || null,
    };
  }
  if (league === "nhl") {
    return {
      id: raw.abbrev ? `nhl-${raw.abbrev}` : null,
      name: raw.abbrev || raw.name?.default || raw.name || null,
    };
  }
  if (league === "ncaam") {
    return {
      id: raw.abbreviation ? `ncaam-${raw.abbreviation}` : null,
      name: raw.abbreviation || raw.shortDisplayName || raw.displayName || null,
    };
  }
  return { id: null, name: null };
}

function toUnifiedGame({
  league,
  date,
  status,
  gameId,
  home,
  away,
  startTime,
  market,
  signals,
  pick,
  whyPanel,
  meta,
}) {
  // Back-compat / UI expectations:
  // - `market.pick` is "home" | "away" | "pass"
  // - UI currently reads `market.whyHeadline` and `market.whyBullets`
  const m = market || {};
  const pickSide = pick?.pickSide || null;

  const pickStr =
    pickSide === "home" ? "home" : pickSide === "away" ? "away" : pickSide === "pass" ? "pass" : null;

  const tier = m.tier || pick?.tier || "PASS";

  return {
    gameId,
    date,
    status: status || "Scheduled",
    startTime: startTime || null,
    home: toUnifiedTeam(league, home),
    away: toUnifiedTeam(league, away),

    market: {
      // ✅ this is what the UI uses
      pick: pickStr === "pass" ? "pass" : pickStr,
      tier,

      // ✅ PASS games should still include some info (edge can be present even when no pick)
      winProb: Number.isFinite(m.winProb) ? m.winProb : null,
      confidence: Number.isFinite(m.confidence) ? m.confidence : null,
      edge: Number.isFinite(m.edge) ? m.edge : null,

      // ✅ “WHY” fields expected by UI
      whyHeadline: whyPanel?.headline || null,
      whyBullets: Array.isArray(whyPanel?.bullets) ? whyPanel.bullets : [],

      // optional market lines if present
      spread: m.spread ?? null,
      total: m.total ?? null,
      moneyline: m.moneyline ?? null,
    },

    // keep richer structures too
    signals: signals || null,
    pick: pick || null,
    why: whyPanel || null,
    meta: meta || null,
  };
}

function addPredictionsAlias(out) {
  const ok = !out?.meta?.error;
  return {
    ok,
    ...out,
    predictions: out.games, // alias for older UI
  };
}

/**
 * NBA helpers
 */
async function getNbaGamesForDate(ymd) {
  const url = `${NBA_API_BASE}/games?per_page=100&dates[]=${encodeURIComponent(ymd)}`;
  const headers = NBA_API_KEY ? { Authorization: NBA_API_KEY } : {};
  const data = await fetchJson(url, {
    cacheKey: `nba:games:${ymd}`,
    cacheTtlMs: HEAVY_CACHE_TTL_MS,
    headers,
  });
  return Array.isArray(data?.data) ? data.data : [];
}

async function getNbaGamesInRange(startYmd, endYmd) {
  // If you call this frequently, it can hammer upstream.
  // Heavy cache + low concurrency should keep it stable.
  const headers = NBA_API_KEY ? { Authorization: NBA_API_KEY } : {};
  const url = `${NBA_API_BASE}/games?per_page=100&start_date=${encodeURIComponent(startYmd)}&end_date=${encodeURIComponent(
    endYmd
  )}`;
  const data = await fetchJson(url, {
    cacheKey: `nba:gamesRange:${startYmd}:${endYmd}`,
    cacheTtlMs: HEAVY_CACHE_TTL_MS,
    headers,
  });
  return Array.isArray(data?.data) ? data.data : [];
}

/**
 * Odds API (DraftKings) — NBA Vegas markets
 */
function americanToImpliedProb(odds) {
  const o = Number(odds);
  if (!Number.isFinite(o) || o === 0) return null;
  if (o > 0) return 100 / (o + 100);
  return (-o) / (-o + 100);
}

function normalizeTeamKey(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, " ")
    .trim();
}

function mkMatchKey(homeName, awayName) {
  return `${normalizeTeamKey(awayName)} @ ${normalizeTeamKey(homeName)}`;
}

function lookupVegasNba(vegasMap, homeName, awayName) {
  if (!vegasMap || !(vegasMap instanceof Map)) return null;
  const key = mkMatchKey(homeName, awayName);
  return vegasMap.get(key) || null;
}

async function fetchNbaVegasForDate(ymd) {
  if (!ODDS_API_KEY) {
    return { ok: false, map: new Map(), reason: "ODDS_API_KEY missing" };
  }

  const { startIso, endIso } = ymdToUtcRange(ymd);

  const qs = new URLSearchParams();
  qs.set("apiKey", ODDS_API_KEY);
  qs.set("regions", "us");
  qs.set("markets", "h2h,spreads,totals");
  qs.set("oddsFormat", "american");
  qs.set("dateFormat", "iso");
  qs.set("bookmakers", ODDS_BOOKMAKER);
  qs.set("commenceTimeFrom", startIso);
  qs.set("commenceTimeTo", endIso);

  const url = `${ODDS_API_BASE}/sports/basketball_nba/odds?${qs.toString()}`;

  const data = await fetchJson(url, {
    cacheKey: `odds:nba:${ODDS_BOOKMAKER}:${ymd}`,
    cacheTtlMs: HEAVY_CACHE_TTL_MS,
    timeoutMs: 15_000,
  });

  const map = new Map();

  const events = Array.isArray(data) ? data : [];
  for (const ev of events) {
    const homeTeam = ev?.home_team;
    const awayTeam = ev?.away_team;
    if (!homeTeam || !awayTeam) continue;

    const book = Array.isArray(ev?.bookmakers) ? ev.bookmakers[0] : null;
    const markets = Array.isArray(book?.markets) ? book.markets : [];

    const row = {
      homeTeam,
      awayTeam,
      h2h: null,
      spreads: null,
      totals: null,
      bookmaker: book?.key || null,
      lastUpdate: book?.last_update || null,
    };

    for (const m of markets) {
      if (m?.key === "h2h") {
        const outs = Array.isArray(m?.outcomes) ? m.outcomes : [];
        const oHome = outs.find((o) => normalizeTeamKey(o?.name) === normalizeTeamKey(homeTeam));
        const oAway = outs.find((o) => normalizeTeamKey(o?.name) === normalizeTeamKey(awayTeam));
        const pHome = americanToImpliedProb(oHome?.price);
        const pAway = americanToImpliedProb(oAway?.price);
        if (pHome != null && pAway != null) {
          // normalized implied probs
          const sum = pHome + pAway;
          row.h2h = {
            pHome: pHome / sum,
            pAway: pAway / sum,
            priceHome: oHome?.price ?? null,
            priceAway: oAway?.price ?? null,
          };
        }
      }
      if (m?.key === "spreads") {
        const outs = Array.isArray(m?.outcomes) ? m.outcomes : [];
        const oHome = outs.find((o) => normalizeTeamKey(o?.name) === normalizeTeamKey(homeTeam));
        const oAway = outs.find((o) => normalizeTeamKey(o?.name) === normalizeTeamKey(awayTeam));
        row.spreads = {
          home: oHome?.point ?? null,
          away: oAway?.point ?? null,
          priceHome: oHome?.price ?? null,
          priceAway: oAway?.price ?? null,
        };
      }
      if (m?.key === "totals") {
        const outs = Array.isArray(m?.outcomes) ? m.outcomes : [];
        const oOver = outs.find((o) => String(o?.name || "").toLowerCase() === "over");
        const oUnder = outs.find((o) => String(o?.name || "").toLowerCase() === "under");
        row.totals = {
          point: oOver?.point ?? oUnder?.point ?? null,
          priceOver: oOver?.price ?? null,
          priceUnder: oUnder?.price ?? null,
        };
      }
    }

    const key = mkMatchKey(homeTeam, awayTeam);
    map.set(key, row);
  }

  return {
    ok: true,
    map,
    meta: {
      bookmaker: ODDS_BOOKMAKER,
      count: map.size,
      from: startIso,
      to: endIso,
    },
  };
}

/**
 * NBA premium scoring (market anchored v2)
 */
function calcEdge(pModel, pMarket) {
  if (!Number.isFinite(pModel) || !Number.isFinite(pMarket)) return null;
  return pModel - pMarket;
}

function tierFromEdge(edge) {
  if (!Number.isFinite(edge)) return "PASS";
  // conservative but usable; you can tune these later
  if (edge >= 0.10) return "ELITE";
  if (edge >= 0.06) return "STRONG";
  if (edge >= 0.03) return "LEAN";
  return "PASS";
}

function confidenceFromWinProb(winProb) {
  if (!Number.isFinite(winProb)) return null;
  // cap if < 0.55 (requested)
  const capped = winProb < 0.55 ? Math.min(winProb, 0.60) : winProb;
  // slightly non-linear lift
  return clamp(0.25 + capped * 0.73, 0.25, 0.95);
}

function makeWhyPanel({ pickSide, tier, pModel, pMarket, edge, vegasRow }) {
  if (!pickSide || pickSide === "pass") return { headline: null, bullets: [] };

  const bullets = [];

  if (Number.isFinite(edge) && Number.isFinite(pMarket)) {
    bullets.push(`Model vs DraftKings implied: ${(pModel * 100).toFixed(1)}% vs ${(pMarket * 100).toFixed(1)}% (edge ${(edge * 100).toFixed(1)}%).`);
  } else if (Number.isFinite(pModel)) {
    bullets.push(`Model win probability: ${(pModel * 100).toFixed(1)}%.`);
  }

  if (vegasRow?.spreads?.home != null || vegasRow?.spreads?.away != null) {
    const sHome = vegasRow?.spreads?.home;
    const sAway = vegasRow?.spreads?.away;
    bullets.push(`DraftKings spread: ${sAway != null ? `Away ${sAway}` : ""}${sAway != null && sHome != null ? " / " : ""}${sHome != null ? `Home ${sHome}` : ""}`.trim());
  }
  if (vegasRow?.totals?.point != null) {
    bullets.push(`DraftKings total: ${vegasRow.totals.point}.`);
  }

  bullets.push(`Tier: ${tier} (market-anchored).`);

  const headline = pickSide === "home" ? "Home side value" : "Away side value";
  return { headline, bullets };
}

async function buildNbaPredictions(dateYYYYMMDD, windowDays, { modelVersion = "v2" } = {}) {
  const mv = String(modelVersion || "v2");
  const warnings = [];

  // Cache whole output (prevents repeated full recompute)
  const predKey = `pred:nba:${dateYYYYMMDD}:${windowDays}:${mv}:${ODDS_BOOKMAKER}`;
  if (predInFlight.has(predKey)) return predInFlight.get(predKey);

  const promise = (async () => {
    const slate = await getNbaGamesForDate(dateYYYYMMDD);

    // Pull vegas once per slate (safe no-op if no ODDS key)
    const vegas = mv === "v2" ? await fetchNbaVegasForDate(dateYYYYMMDD) : { ok: false, map: new Map(), reason: "disabled" };
    const vegasMap = vegas?.ok ? vegas.map : new Map();
    if (mv === "v2" && !vegas?.ok) warnings.push(`Vegas anchoring disabled: ${vegas?.reason || "unknown"}`);

    const games = slate.map((g) => {
      const home = g?.home_team || null;
      const away = g?.visitor_team || null;

      const vegasRow = mv === "v2" ? lookupVegasNba(vegasMap, home?.full_name || home?.name, away?.full_name || away?.name) : null;
      const pHomeMkt = Number.isFinite(vegasRow?.h2h?.pHome) ? vegasRow.h2h.pHome : null;

      // Very simple base model placeholder (you already have richer factors elsewhere)
      // Keep it stable + avoid bias spirals: start from 0.5 and small drift by team_id parity (deterministic)
      const drift = ((Number(home?.id || 0) % 7) - (Number(away?.id || 0) % 7)) * 0.006;
      const pHomeBase = clamp(0.5 + drift, 0.33, 0.67);

      // Anchoring: blend base with market implied
      const anchorAlpha = mv === "v2" && Number.isFinite(pHomeMkt) ? 0.55 : 0;
      const pHome = Number.isFinite(pHomeMkt) ? clamp(pHomeBase * (1 - anchorAlpha) + pHomeMkt * anchorAlpha, 0.05, 0.95) : pHomeBase;

      const pickSide = pHome >= 0.5 ? "home" : "away";
      const pPick = pickSide === "home" ? pHome : 1 - pHome;
      const pMktPick = pickSide === "home" && Number.isFinite(pHomeMkt) ? pHomeMkt : pickSide === "away" && Number.isFinite(pHomeMkt) ? 1 - pHomeMkt : null;

      const edge = calcEdge(pPick, pMktPick);
      const tier = tierFromEdge(edge);
      const confidence = confidenceFromWinProb(pPick);

      const pick =
        tier === "PASS"
          ? { pickSide: "pass", tier: "PASS", edge: edge, confidence: confidence }
          : { pickSide, tier, edge, confidence };

      const whyPanel = makeWhyPanel({
        pickSide: pick.pickSide,
        tier,
        pModel: pPick,
        pMarket: pMktPick,
        edge,
        vegasRow,
      });

      return toUnifiedGame({
        league: "nba",
        date: dateYYYYMMDD,
        status: g?.status || "Scheduled",
        gameId: g?.id ? `nba-${g.id}` : null,
        home: { id: home?.id, abbreviation: home?.abbreviation, name: home?.name },
        away: { id: away?.id, abbreviation: away?.abbreviation, name: away?.name },
        startTime: g?.date || null,
        market: {
          winProb: to3(pPick),
          confidence: confidence != null ? to3(confidence) : null,
          edge: edge != null ? to3(edge) : null,
          tier,
          spread: vegasRow?.spreads || null,
          total: vegasRow?.totals || null,
          moneyline: vegasRow?.h2h || null,
        },
        signals: {
          baseHomeProb: to3(pHomeBase),
          anchoredHomeProb: to3(pHome),
        },
        pick,
        whyPanel,
        meta: {
          modelVersion: mv,
          vegas: mv === "v2" ? (vegasRow || null) : null,
          vegasAnchoring: mv === "v2" ? Boolean(vegasRow?.h2h && Number.isFinite(pHomeMkt) && anchorAlpha > 0) : false,
          vegasAlpha: mv === "v2" ? (anchorAlpha || 0) : 0,
          vegasBookmaker: mv === "v2" ? (vegas?.meta?.bookmaker || null) : null,
        },
      });
    });

    return addPredictionsAlias({
      league: "nba",
      date: dateYYYYMMDD,
      mode: "regular",
      meta: {
        league: "nba",
        date: dateYYYYMMDD,
        windowDays,
        model: "NBA premium-v2-market-anchored",
        modelVersion: mv,
        mode: "regular",
        vegasAnchoring: mv === "v2" ? Boolean(vegas?.ok) : false,
        vegasBookmaker: mv === "v2" ? (vegas?.meta?.bookmaker || null) : null,
        warnings,
      },
      games,
    });
  })();

  predInFlight.set(predKey, promise);
  try {
    return await promise;
  } finally {
    predInFlight.delete(predKey);
  }
}

/**
 * NHL predictions (paused)
 */
async function buildNhlPredictions(dateYYYYMMDD, windowDays, { modelVersion = "v1" } = {}) {
  // NHL paused (olympics / data handling)
  return addPredictionsAlias({
    league: "nhl",
    date: dateYYYYMMDD,
    mode: "regular",
    meta: {
      league: "nhl",
      date: dateYYYYMMDD,
      windowDays,
      model: "NHL paused-v1",
      modelVersion,
      mode: "regular",
      error: null,
      warnings: ["NHL is currently paused."],
    },
    games: [],
  });
}

/**
 * NCAAM predictions (ESPN only)
 */
async function getEspnNcaamScoreboard(ymd) {
  const compact = String(ymd || "").replaceAll("-", "");
  const url = `${ESPN_SITE_V2}/${ESPN_NCAAM_PATH}/scoreboard?dates=${encodeURIComponent(compact)}&groups=50&limit=500`;
  const data = await fetchJson(url, {
    cacheKey: `espn:ncaam:scoreboard:${compact}`,
    cacheTtlMs: HEAVY_CACHE_TTL_MS,
    timeoutMs: 15_000,
  });
  return data;
}

function espnTeamToUnified(team) {
  const abbr = team?.abbreviation || team?.shortDisplayName || team?.displayName || null;
  return {
    abbreviation: team?.abbreviation || null,
    shortDisplayName: team?.shortDisplayName || null,
    displayName: team?.displayName || null,
    id: abbr || null,
  };
}

async function buildNcaamPredictions(dateYYYYMMDD, windowDays, { modelVersion = "v1" } = {}) {
  const warnings = [];
  const sb = await getEspnNcaamScoreboard(dateYYYYMMDD);
  const events = Array.isArray(sb?.events) ? sb.events : [];

  const games = events
    .map((ev) => {
      const comp = Array.isArray(ev?.competitions) ? ev.competitions[0] : null;
      const competitors = Array.isArray(comp?.competitors) ? comp.competitors : [];
      const homeC = competitors.find((c) => c?.homeAway === "home");
      const awayC = competitors.find((c) => c?.homeAway === "away");
      const homeT = homeC?.team;
      const awayT = awayC?.team;

      if (!homeT || !awayT) return null;

      // Simple baseline until Massey/tournament enhancements are wired:
      const pHome = 0.52;
      const pickSide = pHome >= 0.5 ? "home" : "away";
      const pPick = pickSide === "home" ? pHome : 1 - pHome;
      const confidence = confidenceFromWinProb(pPick);
      const tier = "PASS";
      const pick = { pickSide: "pass", tier: "PASS", edge: null, confidence };

      return toUnifiedGame({
        league: "ncaam",
        date: dateYYYYMMDD,
        status: comp?.status?.type?.description || "Scheduled",
        gameId: ev?.id ? `ncaam-${ev.id}` : null,
        home: espnTeamToUnified(homeT),
        away: espnTeamToUnified(awayT),
        startTime: comp?.date || ev?.date || null,
        market: {
          winProb: to3(pPick),
          confidence: confidence != null ? to3(confidence) : null,
          edge: null,
          tier,
        },
        signals: {
          source: "espn-scoreboard",
        },
        pick,
        whyPanel: { headline: null, bullets: [] },
        meta: { modelVersion },
      });
    })
    .filter(Boolean);

  return addPredictionsAlias({
    league: "ncaam",
    date: dateYYYYMMDD,
    mode: "regular",
    meta: {
      league: "ncaam",
      date: dateYYYYMMDD,
      windowDays,
      model: "NCAAM ESPN-v1",
      modelVersion,
      mode: "regular",
      error: null,
      warnings,
      sourceUrl: `${ESPN_SITE_V2}/${ESPN_NCAAM_PATH}/scoreboard`,
    },
    games,
  });
}

/**
 * Router entrypoints
 */
function readDateFromReq(req) {
  return parseYmdOrDefault(req?.query?.date);
}

function readWindowFromReq(req, def = 14, min = 3, max = 120) {
  const n = Number(req?.query?.windowDays ?? req?.query?.days ?? def);
  if (!Number.isFinite(n)) return def;
  return Math.max(min, Math.min(max, Math.round(n)));
}

router.get("/nba/predict", async (req, res) => {
  const date = readDateFromReq(req);
  const windowDays = readWindowFromReq(req, 14, 3, 120);
  const modelVersion = String(req?.query?.modelVersion || "v2");
  try {
    res.json(await buildNbaPredictions(date, windowDays, { modelVersion }));
  } catch (e) {
    res.json(
      addPredictionsAlias({
        league: "nba",
        date,
        mode: "regular",
        meta: {
          league: "nba",
          date,
          windowDays,
          model: "error",
          modelVersion,
          mode: "regular",
          error: String(e?.message || e),
          warnings: [],
        },
        games: [],
      })
    );
  }
});

router.get("/nhl/predict", async (req, res) => {
  const date = readDateFromReq(req);
  const windowDays = readWindowFromReq(req, 60, 3, 120);
  try {
    res.json(await buildNhlPredictions(date, windowDays));
  } catch (e) {
    res.json(
      addPredictionsAlias({
        league: "nhl",
        date,
        mode: "regular",
        meta: { league: "nhl", date, windowDays, model: "error", modelVersion: "v1", mode: "regular", error: String(e?.message || e), warnings: [] },
        games: [],
      })
    );
  }
});

router.get("/ncaam/predict", async (req, res) => {
  const date = readDateFromReq(req);
  const windowDays = readWindowFromReq(req, 14, 3, 120);
  try {
    res.json(await buildNcaamPredictions(date, windowDays));
  } catch (e) {
    res.json(
      addPredictionsAlias({
        league: "ncaam",
        date,
        mode: "regular",
        meta: { league: "ncaam", date, windowDays, model: "error", modelVersion: "v1", mode: "regular", error: String(e?.message || e), warnings: [] },
        games: [],
      })
    );
  }
});

// compatibility: /api/predictions?league=...
router.get("/predictions", async (req, res) => {
  const league = String(req?.query?.league || "nba").toLowerCase();
  const date = readDateFromReq(req);
  const windowDays = readWindowFromReq(req, 14, 3, 120);
  const modelVersion = String(req?.query?.modelVersion || "v2");
  try {
    if (league === "nba") return res.json(await buildNbaPredictions(date, windowDays, { modelVersion }));
    if (league === "nhl") return res.json(await buildNhlPredictions(date, windowDays));
    if (league === "ncaam") return res.json(await buildNcaamPredictions(date, windowDays));
    return res.json(addPredictionsAlias({ league, date, mode: "regular", meta: { league, date, windowDays, model: "error", modelVersion, mode: "regular", error: `Unknown league: ${league}`, warnings: [] }, games: [] }));
  } catch (e) {
    return res.json(
      addPredictionsAlias({
        league,
        date,
        mode: "regular",
        meta: { league, date, windowDays, model: "error", modelVersion, mode: "regular", error: String(e?.message || e), warnings: [] },
        games: [],
      })
    );
  }
});

export default router;

// named exports for adminPerformance
export { buildNbaPredictions, buildNhlPredictions, buildNcaamPredictions };